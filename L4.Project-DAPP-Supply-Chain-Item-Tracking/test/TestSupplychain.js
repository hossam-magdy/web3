// This script is designed to test the solidity smart contract - SuppyChain.sol -- and the various functions within
// Declare a variable and assign the compiled smart contract artifact
const SupplyChain = artifacts.require('SupplyChain');

// Helper, inspired by `truffle-assertions` => simplified version.
const assertEventEmmitted = (txResult, eventName, argsCb = (_) => true) => {
  const foundEvent = txResult.receipt.logs.find((e) => e.event === eventName);
  if (!foundEvent) {
    throw new Error(`Event "${eventName}" was not emitted`);
  }

  const argsMatching = argsCb(foundEvent.args);
  if (!argsMatching) {
    throw new Error(
      `Event "${eventName}" was emitted with non-matchig args: ${JSON.stringify(
        foundEvent.args
      )}`
    );
  }
};

contract('SupplyChain', async (accounts) => {
  // Declare few constants and assign a few sample accounts generated by ganache-cli
  let sku = 0;
  let upc = 0;
  let productID = sku + upc;
  const ownerID = accounts[0];
  const originFarmerID = accounts[1];
  const originFarmName = 'John Doe';
  const originFarmInformation = 'Yarray Valley';
  const originFarmLatitude = '-38.239770';
  const originFarmLongitude = '144.341490';
  const productNotes = 'Best beans for Espresso';
  const productPrice = web3.utils.toWei('0.5', 'ether');
  const distributorID = accounts[2];
  const retailerID = accounts[3];
  const consumerID = accounts[4];
  const emptyAddress = '0x0000000000000000000000000000000000000000';
  const STATE = {
    Harvested: 0,
    Processed: 1,
    Packed: 2,
    ForSale: 3,
    Sold: 4,
    Shipped: 5,
    Received: 6,
    Purchased: 7,
  };

  console.log('Accounts used:');
  console.log('- Contract Owner: accounts[0] ', accounts[0]);
  console.log('- Farmer:         accounts[1] ', accounts[1]);
  console.log('- Distributor:    accounts[2] ', accounts[2]);
  console.log('- Retailer:       accounts[3] ', accounts[3]);
  console.log('- Consumer:       accounts[4] ', accounts[4]);

  //#region TestHelpers, common setup and assertions, that are supply-chain-specific
  const harvestNewItem = async () => {
    sku++;
    upc++;
    productID = sku + upc;

    const supplyChain = await SupplyChain.deployed();

    const harvestResult = await supplyChain.harvestItem(
      upc,
      originFarmerID,
      originFarmName,
      originFarmInformation,
      originFarmLatitude,
      originFarmLongitude,
      productNotes
    );

    return { supplyChain, harvestResult, sku, upc, productID };
  };

  const assertBufferOneResult = (bufferOneResult, { ownerID, sku, upc }) => {
    assert.equal(bufferOneResult[0], sku, 'Error: Invalid item SKU');
    assert.equal(bufferOneResult[1], upc, 'Error: Invalid item UPC');
    assert.equal(
      bufferOneResult[2],
      ownerID,
      'Error: Missing or Invalid ownerID'
    );
    assert.equal(
      bufferOneResult[3],
      originFarmerID,
      'Error: Missing or Invalid originFarmerID'
    );
    assert.equal(
      bufferOneResult[4],
      originFarmName,
      'Error: Missing or Invalid originFarmName'
    );
    assert.equal(
      bufferOneResult[5],
      originFarmInformation,
      'Error: Missing or Invalid originFarmInformation'
    );
    assert.equal(
      bufferOneResult[6],
      originFarmLatitude,
      'Error: Missing or Invalid originFarmLatitude'
    );
    assert.equal(
      bufferOneResult[7],
      originFarmLongitude,
      'Error: Missing or Invalid originFarmLongitude'
    );
  };

  const assertBufferTwoResult = (
    bufferTwoResult,
    {
      sku = undefined,
      upc = undefined,
      productID = undefined,
      productNotes = undefined,
      productPrice = undefined,
      itemState,
      distributorID = undefined,
      retailerID = undefined,
      consumerID = undefined,
    }
  ) => {
    if (sku !== undefined)
      assert.equal(bufferTwoResult[0], sku, 'Error: Invalid SKU');
    if (upc !== undefined)
      assert.equal(bufferTwoResult[1], upc, 'Error: Invalid upc');
    if (productID !== undefined)
      assert.equal(bufferTwoResult[2], productID, 'Error: Invalid productID');
    if (productNotes !== undefined)
      assert.equal(
        bufferTwoResult[3],
        productNotes,
        'Error: Invalid productNotes'
      );
    if (productPrice !== undefined)
      assert.equal(
        bufferTwoResult[4],
        productPrice,
        'Error: Invalid productPrice'
      );
    assert.equal(bufferTwoResult[5], itemState, 'Error: Invalid item State');
    if (distributorID !== undefined)
      assert.equal(
        bufferTwoResult[6],
        distributorID,
        'Error: Invalid distributorID'
      );
    if (retailerID !== undefined)
      assert.equal(bufferTwoResult[7], retailerID, 'Error: Invalid retailerID');
    if (consumerID !== undefined)
      assert.equal(bufferTwoResult[8], consumerID, 'Error: Invalid consumerID');
  };
  //#endregion

  // 0th Test
  it('Testing smart contract can add and renounce roles', async () => {
    const supplyChain = await SupplyChain.deployed();
    await supplyChain.addFarmer(originFarmerID);
    await supplyChain.addDistributor(distributorID);
    await supplyChain.addRetailer(retailerID);
    await supplyChain.addConsumer(consumerID);

    assert.equal(await supplyChain.isFarmer(originFarmerID), true);
    assert.equal(await supplyChain.isDistributor(distributorID), true);
    assert.equal(await supplyChain.isRetailer(retailerID), true);
    assert.equal(await supplyChain.isConsumer(consumerID), true);

    await supplyChain.renounceFarmer({ from: originFarmerID });
    assert.equal(await supplyChain.isFarmer(originFarmerID), false);

    await supplyChain.addFarmer(originFarmerID);
    assert.equal(await supplyChain.isFarmer(originFarmerID), true);
  });

  // 1st Test
  it('Testing smart contract function harvestItem() that allows a farmer to harvest coffee', async () => {
    const { supplyChain, harvestResult, upc, sku } = await harvestNewItem();

    // Retrieve the just now saved item from blockchain by calling function fetchItem()
    const bufferOneResult = await supplyChain.fetchItemBufferOne.call(upc);
    const bufferTwoResult = await supplyChain.fetchItemBufferTwo.call(upc);

    // Verify the result set
    assertEventEmmitted(
      harvestResult,
      'Harvested',
      (args) => args.upc.toNumber() === upc
    );
    assertBufferOneResult(bufferOneResult, { ownerID, sku, upc });
    assertBufferTwoResult(bufferTwoResult, { itemState: STATE.Harvested });
  });

  // 2nd Test
  it('Testing smart contract function processItem() that allows a farmer to process coffee', async () => {
    const { supplyChain, upc, sku } = await harvestNewItem();

    // Mark an item as Processed by calling function processItem()
    const processResult = await supplyChain.processItem(upc);

    // Retrieve the just now saved item from blockchain by calling function fetchItem()
    const bufferOneResult = await supplyChain.fetchItemBufferOne.call(upc);
    const bufferTwoResult = await supplyChain.fetchItemBufferTwo.call(upc);

    // Verify the result set
    assertEventEmmitted(
      processResult,
      'Processed',
      (args) => args.upc.toNumber() === upc
    );
    assertBufferOneResult(bufferOneResult, { ownerID, sku, upc });
    assertBufferTwoResult(bufferTwoResult, { itemState: STATE.Processed });
  });

  // 3rd Test
  it('Testing smart contract function packItem() that allows a farmer to pack coffee', async () => {
    const { supplyChain, upc, sku } = await harvestNewItem();
    await supplyChain.processItem(upc);
    const packResult = await supplyChain.packItem(upc);

    // Retrieve the just now saved item from blockchain by calling function fetchItem()
    const bufferOneResult = await supplyChain.fetchItemBufferOne.call(upc);
    const bufferTwoResult = await supplyChain.fetchItemBufferTwo.call(upc);

    // Verify the result set
    assertEventEmmitted(
      packResult,
      'Packed',
      (args) => args.upc.toNumber() === upc
    );
    assertBufferOneResult(bufferOneResult, { ownerID, sku, upc });
    assertBufferTwoResult(bufferTwoResult, { itemState: STATE.Packed });
  });

  // 4th Test
  it('Testing smart contract function sellItem() that allows a farmer to sell coffee', async () => {
    const { supplyChain, upc, sku } = await harvestNewItem();
    await supplyChain.processItem(upc);
    await supplyChain.packItem(upc);
    const sellResult = await supplyChain.sellItem(upc, productPrice);

    // Retrieve the just now saved item from blockchain by calling function fetchItem()
    const bufferOneResult = await supplyChain.fetchItemBufferOne.call(upc);
    const bufferTwoResult = await supplyChain.fetchItemBufferTwo.call(upc);

    // Verify the result set
    assertEventEmmitted(
      sellResult,
      'ForSale',
      (args) => args.upc.toNumber() === upc
    );
    assertBufferOneResult(bufferOneResult, { ownerID, sku, upc });
    assertBufferTwoResult(bufferTwoResult, {
      itemState: STATE.ForSale,
      productPrice,
    });
  });

  // 5th Test
  it('Testing smart contract function buyItem() that allows a distributor to buy coffee', async () => {
    const { supplyChain, upc, sku } = await harvestNewItem();
    await supplyChain.processItem(upc);
    await supplyChain.packItem(upc);
    await supplyChain.sellItem(upc, productPrice);
    const buyResult = await supplyChain.buyItem(upc, {
      from: distributorID,
      value: productPrice,
    });

    // Retrieve the just now saved item from blockchain by calling function fetchItem()
    const bufferOneResult = await supplyChain.fetchItemBufferOne.call(upc);
    const bufferTwoResult = await supplyChain.fetchItemBufferTwo.call(upc);

    // Verify the result set
    assertEventEmmitted(
      buyResult,
      'Sold',
      (args) => args.upc.toNumber() === upc
    );
    assertBufferOneResult(bufferOneResult, {
      ownerID: distributorID,
      sku,
      upc,
    });
    assertBufferTwoResult(bufferTwoResult, {
      itemState: STATE.Sold,
      productPrice,
    });
  });

  // 6th Test
  it('Testing smart contract function shipItem() that allows a distributor to ship coffee', async () => {
    const { supplyChain, upc, sku } = await harvestNewItem();
    await supplyChain.processItem(upc);
    await supplyChain.packItem(upc);
    await supplyChain.sellItem(upc, productPrice);
    await supplyChain.buyItem(upc, {
      from: distributorID,
      value: productPrice,
    });
    const shipResult = await supplyChain.shipItem(upc);

    // Retrieve the just now saved item from blockchain by calling function fetchItem()
    const bufferOneResult = await supplyChain.fetchItemBufferOne.call(upc);
    const bufferTwoResult = await supplyChain.fetchItemBufferTwo.call(upc);

    // Verify the result set
    assertEventEmmitted(
      shipResult,
      'Shipped',
      (args) => args.upc.toNumber() === upc
    );
    assertBufferOneResult(bufferOneResult, {
      ownerID: distributorID,
      sku,
      upc,
    });
    assertBufferTwoResult(bufferTwoResult, {
      itemState: STATE.Shipped,
      productPrice,
    });
  });

  // 7th Test
  it('Testing smart contract function receiveItem() that allows a retailer to mark coffee received', async () => {
    const { supplyChain, upc, sku } = await harvestNewItem();
    await supplyChain.processItem(upc);
    await supplyChain.packItem(upc);
    await supplyChain.sellItem(upc, productPrice);
    await supplyChain.buyItem(upc, {
      from: distributorID,
      value: productPrice,
    });
    await supplyChain.shipItem(upc);
    const receiveResult = await supplyChain.receiveItem(upc);

    // Retrieve the just now saved item from blockchain by calling function fetchItem()
    const bufferOneResult = await supplyChain.fetchItemBufferOne.call(upc);
    const bufferTwoResult = await supplyChain.fetchItemBufferTwo.call(upc);

    // Verify the result set
    assertEventEmmitted(
      receiveResult,
      'Received',
      (args) => args.upc.toNumber() === upc
    );
    assertBufferOneResult(bufferOneResult, { ownerID, sku, upc });
    assertBufferTwoResult(bufferTwoResult, {
      itemState: STATE.Received,
      productPrice,
    });
  });

  // 8th Test
  it('Testing smart contract function purchaseItem() that allows a consumer to purchase coffee', async () => {
    const { supplyChain, upc, sku } = await harvestNewItem();
    await supplyChain.processItem(upc);
    await supplyChain.packItem(upc);
    await supplyChain.sellItem(upc, productPrice);
    await supplyChain.buyItem(upc, {
      from: distributorID,
      value: productPrice,
    });
    await supplyChain.shipItem(upc);
    await supplyChain.receiveItem(upc);
    const purchaseResult = await supplyChain.purchaseItem(upc, {
      from: consumerID,
    });

    // Retrieve the just now saved item from blockchain by calling function fetchItem()
    const bufferOneResult = await supplyChain.fetchItemBufferOne.call(upc);
    const bufferTwoResult = await supplyChain.fetchItemBufferTwo.call(upc);

    // Verify the result set
    assertEventEmmitted(
      purchaseResult,
      'Purchased',
      (args) => args.upc.toNumber() === upc
    );
    assertBufferOneResult(bufferOneResult, { ownerID: consumerID, sku, upc });
    assertBufferTwoResult(bufferTwoResult, {
      itemState: STATE.Purchased,
      productPrice,
    });
  });

  // 9th Test
  it('Testing smart contract function fetchItemBufferOne() that allows anyone to fetch item details from blockchain', async () => {
    const { supplyChain, upc, sku } = await harvestNewItem();

    // Retrieve the just now saved item from blockchain by calling function fetchItem()
    const bufferOneResult = await supplyChain.fetchItemBufferOne.call(upc);

    // Verify the result set:
    assertBufferOneResult(bufferOneResult, { ownerID, sku, upc });
  });

  // 10th Test
  it('Testing smart contract function fetchItemBufferTwo() that allows anyone to fetch item details from blockchain', async () => {
    const { supplyChain, upc, sku, productID } = await harvestNewItem();

    // Retrieve the just now saved item from blockchain by calling function fetchItem()
    const bufferTwoResult = await supplyChain.fetchItemBufferTwo.call(upc);

    // Verify the result set:
    assertBufferTwoResult(bufferTwoResult, {
      sku,
      upc,
      productID,
      productNotes,
      productPrice: 0,
      itemState: STATE.Harvested,
      distributorID: emptyAddress,
      retailerID: emptyAddress,
      consumerID: emptyAddress,
    });
  });
});
